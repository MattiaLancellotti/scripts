#!/bin/bash
#
#==============================================================================
#
#         FILE: fast-pass
#
#        USAGE: TODO
#
#  DESCRIPTION: TODO
#
#      OPTIONS: See usage function below.
# REQUIREMENTS: TODO
#         BUGS: ---
#        NOTES: TODO
#       AUTHOR: Lancellotti Mattia
#      COMPANY: ---
#      VERSION: 1.0
#      CREATED: 01/11/2021
#     REVISION: ---
#==============================================================================

source $UTILITIES/include/system.sh
source $UTILITIES/include/logging.sh

# This script needs gpg
check_command gpg || die_on_error "You need gpg to encrypt your passwords." 1;

# Creating a local database
PROG_FILES=${HOME}/.local/share/fast-pass
LOCAL_DB="$PROG_FILES/passwords.tar"
ENCRYPTED_DB="$LOCAL_DB.gpg"

mkdir -p $PROG_FILES

usage() {
  log "fast-pass - simple bash script to store passwords."
  cat <<- EOF
  -h, --help : prints out this message.
  -l, --list : lists all the stored passwords.
  -n, --new  : stores a new password (via input).
  -d, --del  : deletes a stored password.
  --delete-all ! deletes all the passwords.

  Examples:
    fast-pass [-l|--list]       : (Will list all the saved passwords)
    fast-pass (-n|--new) <name> : (Will store the new password under <name>)
    fast-pass <name>            : (If it exists ? show the password : create it)
EOF
}

# Listing all the passwords
# TODO:
#   - Nice formatting of the passwords;
#   - Maybe add the date it was added (creation date of the file);
#   - Check if the user entered the right password.
list_passwds() {
  [ ! -f $ENCRYPTED_DB ] && \
    log "No passwords saved." && exit 0;

  # Decrypting and listing the content of the archive
  gpg --decrypt --no-symkey-cache --output $LOCAL_DB $ENCRYPTED_DB;
  [ $? -ne 0 ] && die_on_error "Wrong password." 1;

  tar -tvf $LOCAL_DB;

  # Removing the decrypted archive by shreding it
  shred --remove=wipesync --zero --exact $LOCAL_DB;
}

chck_passwd() {
  [ ! -f $ENCRYPTED_DB ] && \
    warn "No database found." && exit 1;

  # Decrypting the database to check whether the given password is already
  # stored.
  gpg --decrypt --no-symkey-cache --output $LOCAL_DB $ENCRYPTED_DB;
  [ $? -ne 0 ] && die_on_error "Wrong password." 1;

  # Searching for the password.
  local hash=$(echo $1 | sha256sum | awk '{print $1}')
  local hashes=($(tar -tvf $LOCAL_DB | awk '{print $6}'))
  for i in ${hashes[@]}; do
    [[ "$i" == "$hash" ]] && exit 256;
  done

  # If the function gets here it means that the password name was not found. In
  # this case it automatically gets created.
  create_passwd $1;
}

create_passwd() {
  # Asking the user to input the password
  log "Type the password you want so store:"
  read -s passwd;

  local pfile_db="/tmp/$(echo $1 | sha256sum | awk '{print $1}')"
  echo $passwd > $pfile_db

  (
  flock 10;
  if [ ! -f $ENCRYPTED_DB ]; then
    log "Creating the passwords database.";
    tar -C /tmp -cvf $LOCAL_DB "$(basename $pfile_db)";
    gpg --symmetric --no-symkey-cache -o $ENCRYPTED_DB $LOCAL_DB;
  else
    gpg --decrypt --no-symkey-cache -o $LOCAL_DB $ENCRYPTED_DB;
    tar -C /tmp -uf $LOCAL_DB $(basename $pfile_db);
    gpg --symmetric --no-symkey-cache -o $ENCRYPTED_DB $LOCAL_DB;
  fi
  ) 10<$pfile_db

  shred --remove=wipesync --zero --exact $pfile_db $LOCAL_DB;
}

# If no arguments were supplied, than list all the saved passwords.
[ $# -eq 0 ] && list_passwds

# Parses the arguments passed to the script.
set -- "$@"
while [ $# -gt 0 ]; do
  case "$1" in
    -n) create_passwd $2; shift 2;;

    --new=*) create_passwd ${1#*=}; shift 1;;

    --list|-l) list_passwds; shift 1;;
    --help|-h) usage; exit 0;;

    --del|-d) log "Coming soon"; shift 1;;
    --get|-g) log "Coming soon"; shift 1;;
    --delete-all) log "Coming soon"; shift 1;;

    *) chck_passwd $1; exit $?;;
  esac
done

exit 0;
